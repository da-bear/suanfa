"""
某公司出售钢条，出售价格与钢条长度之间的关系如下表：
    长度(r)   1  2  3  4  5  6  7  8  9  10
    价格(p)   1  5  8  9  10 17 17 20 24 30

问题： 现有一段长度为n的钢条和上面的价格，求切割钢条方案，是得总收益最大

思考：长度为n的钢条的不同切割方案有几种 2 ** （n-1）

设长度为n的钢条切割后的最优收益为rn
    rn = max(pn, r1+ rn-1 ,r2 + rn-2 .........)
    第一个参数pn表示不切割
    其他的n-1个参数分别表示另外n-1种不同切割方法，对方案i=1,2,....n-1
        将钢条切割为长度为i和n-1 两段
        方案i的收益为切割两段的最有收益之和
    考察所有的i，选择其中收益最大的方案

    可以将求解规模为n的原问题，划分为规模更小的子问题：
    完成一次切割后，可以将产生的两端钢条看成两个独立的钢条切割问题
    组合两个子问题的最优解，并在所有可能的两端切割方案中选取组合收益最大的，构成原问题的最优解
    钢条切割满足最优子结构，问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解

更简单的递归求解
    从钢条的左边切割下长度为i的一段，只对右边剩下的一段继续进行切割，左边的不在切割
    递推式简化为
        rn = max（pi + rn-i）(1 - n)
    不做切割的方案就可以描述为：左边一段长度为n，收益为pn，剩余一段长度为0，收益为r0 = 0

❌❌注意:当前的方法复杂度太高，是自顶向下的递归方式，效率很差，存在很大程度的重复
"""
from base_file.cal_time import timeit

p0 = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]


def cut_rod_1(p, n):
    if n == 0:
        return 0
    res = p[n]
    for i in range(1, n):
        res = max(res, cut_rod_1(p, i) + cut_rod_1(p, n - i))
    return res


def cut_rod_2(p, n):
    if n == 0:
        return 0
    res = 0
    for i in range(1, n + 1):
        res = max(res, p[i] + cut_rod_2(p, n - i))
    return res

@timeit
def c1(p, n):
    return cut_rod_1(p, n)

@timeit
def c2(p, n):
    return cut_rod_2(p, n)


if __name__ == '__main__':
    # 复杂度过高
    print(c1(p0, 10))
    print(c2(p0, 10))